"use client";
import React, { useRef, useEffect, useCallback, act, use } from "react";

import Editor, { Monaco } from "@monaco-editor/react";
import { TemplateFile } from "../lib/path-to-jason";
import {
  configureMonaco,
  defaultEditorOptions,
  getEditorLanguage,
} from "../lib/editor-config";
import { ca, is, ta } from "date-fns/locale";
import { Value } from "@radix-ui/react-select";
import { set } from "zod";
interface CodeEditorProps {
  activeFile: TemplateFile | undefined;
  content: string;
  onContentChange(value: string): void;
  suggestion: string | null;
  suggestionLoading: boolean;
  suggestionPosition: { line: number; column: number } | null;
  onAcceptSuggestion(editor: any, monaco: Monaco): void;
  onRejectSuggestion(type: string, editor: any): void;
  onTriggerSuggestion(type: string, editor: any): void;
}

const CodeEditor = ({
  activeFile,
  content,
  onContentChange,
  suggestion,
  suggestionLoading,
  suggestionPosition,
  onAcceptSuggestion,
  onRejectSuggestion,
  onTriggerSuggestion,
}: CodeEditorProps) => {
  const monacoRef = useRef<Monaco | null>(null);
  const editorRef = useRef<any>(null);
  const inlineCompletionProviderRef = useRef<any>(null);
  const currentSuggestionRef = useRef<{
    text: string;
    postion: { line: number; column: number };
    id: string;
  } | null>(null);
  const isAcceptingSuggestionRef = useRef(false);
  const suggestionAcceptedRef = useRef(false);
  const suggestionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const tabCommandRef = useRef<any>(null);

  const generateSuggestionId = () =>
    `suggestion-${Date.now()}-${Math.random()}`;
  const createInlineCompletionProvider = useCallback(
    (monaco: Monaco) => {
      return {
        provideInlineCompletions: async (position: any) => {
          if (
            isAcceptingSuggestionRef.current ||
            suggestionAcceptedRef.current
          ) {
            console.log(
              "Skipping completion because suggestion is being accepted or has been accepted",
            );
            return { items: [] };
          }
          if (!suggestion || !suggestionPosition) {
            return { items: [] };
          }
          const currentLine = position.lineNumber;
          const currentColumn = position.column;

          const isPositionMatching =
            currentLine === suggestionPosition.line &&
            currentColumn >= suggestionPosition.column &&
            currentColumn <= suggestionPosition.column + 2;

          if (!isPositionMatching) {
            console.log(
              `Cursor moved to line ${currentLine}, column ${currentColumn}, which is outside the suggestion range. Hiding suggestion.`,
              {
                current: `${currentLine}:${currentColumn}`,
                expected: `${suggestionPosition.line}:${suggestionPosition.column} - ${suggestionPosition.column}`,
              },
            );
            return { items: [] };
          }

          const suggestionId = generateSuggestionId();
          currentSuggestionRef.current = {
            text: suggestion,
            postion: suggestionPosition,
            id: suggestionId,
          };

          const cleanSuggestion = suggestion.replace(/\n/g, "\n");

          return {
            items: [
              {
                insertText: cleanSuggestion,
                range: new monaco.Range(
                  suggestionPosition.line,
                  suggestionPosition.column,
                  suggestionPosition.line,
                  suggestionPosition.column,
                ),
                kind: monaco.languages.InlineCompletionItemKind.snippet,
                label: "AI Suggestion",
                detail: "Suggestion generated by AI based on your code context",
                documentation:
                  "Press Tab to accept the suggestion, or keep typing to ignore it.",
                sortText: "0000",
                filterText: cleanSuggestion,
                insertTextRules:
                  monaco.languages.InlineCompletionItemInsertTextRule
                    .InsertAsSnippet,
              },
            ],
          };
        },
        freeInlineCompletions: (completions: any) => {
          console.log("Freeing inline completions called");
        },
      };
    },
    [suggestion, suggestionPosition],
  );

  // clear current suggestion
  const clearCurrentSuggestion = useCallback(() => {
    console.log("Clearing current suggestion");
    currentSuggestionRef.current = null;
    suggestionAcceptedRef.current = false;
    if (editorRef.current) {
      editorRef.current.trigger("ai", "editor.action.inlineSuggest.hide", null);
    }
  }, []);

  // acept curren suggestion with douable  aceptance logic
  const acceptCurrentSuggestion = useCallback(() => {
    if (
      !editorRef.current ||
      !monacoRef.current ||
      !currentSuggestionRef.current
    ) {
      console.log(
        "Cannot accept suggestion: editor, monaco, or current suggestion is not available",
      );
      return false;
    }

    if (!isAcceptingSuggestionRef.current || suggestionAcceptedRef.current) {
      console.log(
        "Cannot accept suggestion: not currently accepting or suggestion already accepted",
      );
      return false;
    }

    isAcceptingSuggestionRef.current = true;
    suggestionAcceptedRef.current = true;

    const editor = editorRef.current;
    const monaco = monacoRef.current;
    const currentSuggestion = currentSuggestionRef.current;

    try {
      const cleanSuggestion = currentSuggestion.text.replace(/\n/g, "\n");
      //getting current cursor position to verify it's still in the suggestion range after acceptance
      const currentPosition = editor.getPosition();
      const suggestionpos = currentSuggestion.postion;

      if (
        currentPosition.lineNumber !== suggestionpos.line ||
        currentPosition.column < suggestionpos.column ||
        currentPosition.column > suggestionpos.column + 5
      ) {
        console.log(
          "position mismatch on acceptance, current position:",
          currentPosition,
          "suggestion position:",
          suggestionpos,
        );
        return false;
      }
      const range = new monaco.Range(
        suggestionpos.line,
        suggestionpos.column,
        suggestionpos.line,
        suggestionpos.column,
      );
      const success = editor.executeEdits("ai-suggestion-accept", [
        {
          range,
          text: cleanSuggestion,
          forceMoveMarkers: true,
        },
      ]);
      if (!success) {
        console.log("Failed to apply suggestion edits");
        return false;
      }

      const lines = cleanSuggestion.split("\n");
      const endLine = suggestionpos.line + lines.length - 1;
      const endColumn =
        lines.length === 1
          ? suggestionpos.column + cleanSuggestion.length
          : lines[lines.length - 1].length + 1;
      editor.setPosition({ lineNumber: endLine, column: endColumn });
      clearCurrentSuggestion();
      onAcceptSuggestion(editor, monaco);
      return true;
    } catch (error) {
      console.error("Error accepting suggestion:", error);
      return false;
    } finally {
      // reset accepting state after a short delay to prevent rapid re-acceptance
      isAcceptingSuggestionRef.current = false;

      //keep accepting state true for a short window to allow for double acceptance if user quickly presses tab again
      setTimeout(() => {
        suggestionAcceptedRef.current = false;
        console.log("Resetting suggestion accepted state after delay");
      }, 1000);
    }
  }, [clearCurrentSuggestion, onAcceptSuggestion]);

  const hasActiveSuggestionAtposition = useCallback(() => {
    if (!editorRef.current || !currentSuggestionRef.current) return false;

    const postion = editorRef.current.getPosition();
    const suggestion = currentSuggestionRef.current;

    return (
      postion.lineNumber === suggestion.postion.line &&
      postion.column >= suggestion.postion.column &&
      postion.column <= suggestion.postion.column + 2
    );
  }, []);

  useEffect(() => {
    if (!editorRef.current || !monacoRef.current) return;

    const editor = editorRef.current;
    const monaco = monacoRef.current;

    if (isAcceptingSuggestionRef.current || suggestionAcceptedRef.current) {
      console.log(
        "skipping keydown handler because suggestion is being accepted or has been accepted",
      );
      return;
    }

    if (inlineCompletionProviderRef.current) {
      inlineCompletionProviderRef.current.dispose();
      inlineCompletionProviderRef.current = null;
    }

    //clear current suggestion refrence
    currentSuggestionRef.current = null;

    if (suggestion && suggestionPosition) {
      const language = getEditorLanguage(activeFile?.fileExtension || "");
      const provider = createInlineCompletionProvider(monaco);
      inlineCompletionProviderRef.current =
        monaco.languages.registerInlineCompletionsProvider(language, provider);
      console.log(
        "Registered inline completion provider for language:",
        language,
      );

      //small delay to ensure provider is registered before triggering suggestion
      setTimeout(() => {
        if (
          editorRef.current &&
          !isAcceptingSuggestionRef.current &&
          !suggestionAcceptedRef.current
        ) {
          console.log(
            "Triggering inline suggestion after provider registration",
          );
          editorRef.current.trigger(
            "ai",
            "editor.action.inlineSuggest.trigger",
            null,
          );
        }
      }, 50);
    }

    return () => {
      if (inlineCompletionProviderRef.current) {
        inlineCompletionProviderRef.current.dispose();
        inlineCompletionProviderRef.current = null;
      }
    };
  }, [
    suggestion,
    suggestionPosition,
    activeFile,
    createInlineCompletionProvider,
  ]);
  const handleEditorDidMount = useCallback((editor: any, monaco: Monaco) => {
    editorRef.current = editor;
    monacoRef.current = monaco;

    editor.updateOptions({
      ...defaultEditorOptions,
      // Override Tab key behavior when suggestion is active
      inlinesuggest: {
        enabled: true,
        mode: "prefix",
        suppressSuggestions: false,
      },
      suggest: {
        preview: false,
        showInlineDetails: false,
        insertMode: "replace",
      },
      quickSuggestions: {
        other: true,
        comments: false,
        strings: false,
      },
      cursorSmoothCaretAnimation: "on",
    });

    configureMonaco(monaco);

    editor.addCommand(monaco.keyMod.ctrlCmd | monaco.KeyCode.Space, () => {
      onTriggerSuggestion("completion", editor);
    });
    if (tabCommandRef.current) {
      tabCommandRef.current.dispose();
    }
    updateEditorLanguage();
  }, []);
  const updateEditorLanguage = () => {
    if (!activeFile || !monacoRef.current || !editorRef.current) return;
    const model = editorRef.current.getModel();
    if (!model) return;
    const language = getEditorLanguage(activeFile.fileExtension || "");
    try {
      monacoRef.current.editor.setModelLanguage(model, language);
    } catch (error) {
      console.error("Error setting model language:", error);
    }
  };

  useEffect(() => {
    updateEditorLanguage();
  }, [activeFile]);

  return (
    <div className="h-full relative">
      {/*Ai*/}
      <Editor
        height={"100%"}
        value={content}
        onChange={(value) => onContentChange(value || "")}
        onMount={handleEditorDidMount}
        language={
          activeFile
            ? getEditorLanguage(activeFile.fileExtension || "")
            : "plaintext"
        }
        //@ts-ignore
        options={defaultEditorOptions}
      />
    </div>
  );
};

export default CodeEditor;
